<?xml version="1.0" encoding="UTF-8"?>
<model version="5.1.3" links="1">
 <documentation>Dining Philosopher Problem example with the &quot;Orthogonal Component&quot; state pattern (see https://www.state-machine.com/doc/Pattern_Orthogonal.pdf)

The model demonstrates the following features:

1. Partitioning the application into Container and Components
2. Packages for Container (cont) and Components (comp)
3. External packages with speparate QM-package model files
4. CompTimeEvt class for private time evnents of Components
5. Container to Component communication via synchronous event dispatching
6. Component to Container communication via asynchronous event posting using the LIFO policy.</documentation>
 <!--${qpcpp}-->
 <framework name="qpcpp"/>
 <!--${Cont}-->
 <package name="Cont" stereotype="0x02" namespace="DPP::">
  <!--${Cont::TableEvt}-->
  <class name="TableEvt" superclass="qpcpp::QEvt">
   <!--${Cont::TableEvt::philo_id}-->
   <attribute name="philo_id" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <!--${Cont::CompTimeEvt}-->
  <class name="CompTimeEvt" superclass="qpcpp::QTimeEvt">
   <documentation>Specialized time event for components. The time evnet can be owned by a component and can dispatch itself to the component.</documentation>
   <!--${Cont::CompTimeEvt::id}-->
   <attribute name="id" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${Cont::CompTimeEvt::CompTimeEvt}-->
   <operation name="CompTimeEvt" type="" visibility="0x00" properties="0x00">
    <documentation>The constructor to initialize a Component Time Event.

When creating a time event, you must commit it to a specific active object 'act',  event signal 'sig', and tick rate 'tickRate'. You cannot change these attributes later.</documentation>
    <!--${Cont::CompTimeEvt::CompTimeEvt::act}-->
    <parameter name="act" type="QP::QActive *"/>
    <!--${Cont::CompTimeEvt::CompTimeEvt::sig}-->
    <parameter name="sig" type="enum_t const"/>
    <!--${Cont::CompTimeEvt::CompTimeEvt::tickRate}-->
    <parameter name="tickRate" type="uint_fast8_t const"/>
    <code> : QTimeEvt(act, sig, tickRate)</code>
   </operation>
  </class>
  <!--${Cont::Table}-->
  <class name="Table" superclass="qpcpp::QActive">
   <!--${Cont::Table::inst}-->
   <attribute name="inst" type="Table" visibility="0x00" properties="0x01">
    <documentation>The only static instance of the Table class (Singleton pattern)</documentation>
   </attribute>
   <!--${Cont::Table::m_philo[N_PHILO]}-->
   <attribute name="m_philo[N_PHILO]" type="Philo" visibility="0x02" properties="0x00">
    <documentation>Embedded component state machine objects</documentation>
   </attribute>
   <!--${Cont::Table::m_fork[N_PHILO]}-->
   <attribute name="m_fork[N_PHILO]" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${Cont::Table::m_isHungry[N_PHILO]}-->
   <attribute name="m_isHungry[N_PHILO]" type="bool" visibility="0x02" properties="0x00"/>
   <!--${Cont::Table::Table}-->
   <operation name="Table" type="" visibility="0x00" properties="0x00">
    <code>  : QActive(Q_STATE_CAST(&amp;Table::initial))

for (uint8_t n = 0U; n &lt; N_PHILO; ++n) {
    m_fork[n] = FREE;
    m_isHungry[n] = false;
    m_philo[n].setId(n);
}</code>
   </operation>
   <!--${Cont::Table::SM}-->
   <statechart properties="0x02">
    <!--${Cont::Table::SM::initial}-->
    <initial target="../1/3">
     <action>(void)e; // unused parameter

QS_OBJ_DICTIONARY(&amp;Table::inst);
QS_OBJ_DICTIONARY(&amp;m_philo[0]);
QS_OBJ_DICTIONARY(&amp;m_philo[0].m_timeEvt);
QS_OBJ_DICTIONARY(&amp;m_philo[1]);
QS_OBJ_DICTIONARY(&amp;m_philo[1].m_timeEvt);
QS_OBJ_DICTIONARY(&amp;m_philo[2]);
QS_OBJ_DICTIONARY(&amp;m_philo[2].m_timeEvt);
QS_OBJ_DICTIONARY(&amp;m_philo[3]);
QS_OBJ_DICTIONARY(&amp;m_philo[3].m_timeEvt);
QS_OBJ_DICTIONARY(&amp;m_philo[4]);
QS_OBJ_DICTIONARY(&amp;m_philo[4].m_timeEvt);

// global signals
QS_SIG_DICTIONARY(DONE_SIG,      (void *)0);
QS_SIG_DICTIONARY(EAT_SIG,       (void *)0);
QS_SIG_DICTIONARY(PAUSE_SIG,     (void *)0);
QS_SIG_DICTIONARY(SERVE_SIG,     (void *)0);
QS_SIG_DICTIONARY(TEST_SIG,      (void *)0);
QS_SIG_DICTIONARY(HUNGRY_SIG,    (void *)0);
QS_SIG_DICTIONARY(HUNGRY_SIG,    (void *)0);
QS_SIG_DICTIONARY(TIMEOUT_SIG,   (void *)0);

subscribe(PAUSE_SIG);
subscribe(SERVE_SIG);
subscribe(TEST_SIG);

for (uint8_t n = 0U; n &lt; N_PHILO; ++n) {
    m_philo[n].init(m_prio); // top-most initial tran.
    m_fork[n] = FREE;
    m_isHungry[n] = false;
    BSP::displayPhilStat(n, THINKING);
}</action>
     <initial_glyph conn="2,4,5,1,44,23,-8">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <!--${Cont::Table::SM::active}-->
    <state name="active">
     <!--${Cont::Table::SM::active::EAT}-->
     <tran trig="EAT">
      <action>Q_ERROR();</action>
      <tran_glyph conn="2,16,3,-1,14">
       <action box="0,-2,10,4"/>
      </tran_glyph>
     </tran>
     <!--${Cont::Table::SM::active::TEST}-->
     <tran trig="TEST">
      <tran_glyph conn="2,20,3,-1,14">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${Cont::Table::SM::active::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>uint8_t id = Q_EVT_CAST(CompTimeEvt)-&gt;id;
m_philo[id].dispatch(e, m_prio);</action>
      <tran_glyph conn="2,12,3,-1,14">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${Cont::Table::SM::active::serving}-->
     <state name="serving">
      <entry brief="give pending permitions to eat">for (uint8_t n = 0U; n &lt; N_PHILO; ++n) { // give permissions to eat...
    if (m_isHungry[n]
        &amp;&amp; (m_fork[LEFT(n)] == FREE)
        &amp;&amp; (m_fork[n] == FREE))
    {
        m_fork[LEFT(n)] = USED;
        m_fork[n] = USED;

        // synchronoulsy dispatch EAT event to the Philo component
        TableEvt evt;
        evt.sig = EAT_SIG;
        evt.philo_id = m_philo[n].getId();
        m_philo[n].dispatch(&amp;evt, m_prio);

        m_isHungry[n] = false;
        BSP::displayPhilStat(n, EATING);
    }
}</entry>
      <!--${Cont::Table::SM::active::serving::HUNGRY}-->
      <tran trig="HUNGRY">
       <action>// find the index of the Philo from the event
uint8_t n = Q_EVT_CAST(TableEvt)-&gt;philo_id;
// philo ID must be in range and he must be not hungry
Q_ASSERT((n &lt; N_PHILO) &amp;&amp; (!m_isHungry[n]));

BSP::displayPhilStat(n, HUNGRY);
uint8_t m = LEFT(n);</action>
       <!--${Cont::Table::SM::active::serving::HUNGRY::[bothfree]}-->
       <choice>
        <guard brief="both free">(m_fork[m] == FREE) &amp;&amp; (m_fork[n] == FREE)</guard>
        <action>m_fork[m] = USED;
m_fork[n] = USED;

// synchronoulsy dispatch EAT event to the Philo component
TableEvt evt;
evt.sig = EAT_SIG;
evt.philo_id = m_philo[n].getId();
m_philo[n].dispatch(&amp;evt, m_prio);

BSP::displayPhilStat(n, EATING);</action>
        <choice_glyph conn="20,32,5,-1,10">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <!--${Cont::Table::SM::active::serving::HUNGRY::[else]}-->
       <choice>
        <guard>else</guard>
        <action>m_isHungry[n] = true;</action>
        <choice_glyph conn="20,32,4,-1,4,10">
         <action box="1,4,6,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="4,32,3,-1,16">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <!--${Cont::Table::SM::active::serving::DONE}-->
      <tran trig="DONE">
       <action>// find the index of the Philo from the event
uint8_t n = Q_EVT_CAST(TableEvt)-&gt;philo_id;
// philo ID must be in range and he must be not hungry
Q_ASSERT((n &lt; N_PHILO) &amp;&amp; (!m_isHungry[n]));

BSP::displayPhilStat(n, THINKING);
uint8_t m = LEFT(n);
// both forks of Phil[n] must be used
Q_ASSERT((m_fork[n] == USED) &amp;&amp; (m_fork[m] == USED));

m_fork[m] = FREE;
m_fork[n] = FREE;
m = RIGHT(n); // check the right neighbor

if (m_isHungry[m] &amp;&amp; (m_fork[m] == FREE)) {
    m_fork[n] = USED;
    m_fork[m] = USED;
    m_isHungry[m] = false;

    // synchronoulsy dispatch EAT event to the Philo component
    TableEvt evt;
    evt.sig = EAT_SIG;
    evt.philo_id = m_philo[m].getId();
    m_philo[m].dispatch(&amp;evt, m_prio);

    BSP::displayPhilStat(m, EATING);
}
m = LEFT(n); // check the left neighbor
n = LEFT(m); // left fork of the left neighbor
if (m_isHungry[m] &amp;&amp; (m_fork[n] == FREE)) {
    m_fork[m] = USED;
    m_fork[n] = USED;
    m_isHungry[m] = false;

    // synchronoulsy dispatch EAT event to the Philo component
    TableEvt evt;
    evt.sig = EAT_SIG;
    evt.philo_id = m_philo[m].getId();
    m_philo[m].dispatch(&amp;evt, m_prio);

    BSP::displayPhilStat(m, EATING);
}</action>
       <tran_glyph conn="4,40,3,-1,16">
        <action box="0,-2,6,2"/>
       </tran_glyph>
      </tran>
      <!--${Cont::Table::SM::active::serving::EAT}-->
      <tran trig="EAT">
       <action>Q_ERROR();</action>
       <tran_glyph conn="4,44,3,-1,16">
        <action box="0,-2,12,4"/>
       </tran_glyph>
      </tran>
      <!--${Cont::Table::SM::active::serving::PAUSE}-->
      <tran trig="PAUSE" target="../../4">
       <tran_glyph conn="4,48,3,1,36,8,-2">
        <action box="0,-2,7,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="4,24,34,26">
       <entry box="1,2,27,2"/>
      </state_glyph>
     </state>
     <!--${Cont::Table::SM::active::paused}-->
     <state name="paused">
      <entry>BSP::displayPaused(1U);</entry>
      <exit>BSP::displayPaused(0U);</exit>
      <!--${Cont::Table::SM::active::paused::SERVE}-->
      <tran trig="SERVE" target="../../3">
       <tran_glyph conn="4,66,3,1,38,-32,-4">
        <action box="0,-2,12,2"/>
       </tran_glyph>
      </tran>
      <!--${Cont::Table::SM::active::paused::HUNGRY}-->
      <tran trig="HUNGRY">
       <action>// find the index of the Philo from the event
uint8_t n = Q_EVT_CAST(TableEvt)-&gt;philo_id;
// philo ID must be in range and he must be not hungry
Q_ASSERT((n &lt; N_PHILO) &amp;&amp; (!m_isHungry[n]));

m_isHungry[n] = true;
BSP::displayPhilStat(n, HUNGRY);</action>
       <tran_glyph conn="4,70,3,-1,16">
        <action box="0,-2,9,2"/>
       </tran_glyph>
      </tran>
      <!--${Cont::Table::SM::active::paused::DONE}-->
      <tran trig="DONE">
       <action>// find the index of the Philo from the event
uint8_t n = Q_EVT_CAST(TableEvt)-&gt;philo_id;
// philo ID must be in range and he must be not hungry
Q_ASSERT((n &lt; N_PHILO) &amp;&amp; (!m_isHungry[n]));

BSP::displayPhilStat(n, THINKING);

uint8_t m = LEFT(n);
// both forks of Phil[n] must be used
Q_ASSERT((m_fork[n] == USED) &amp;&amp; (m_fork[m] == USED));

m_fork[m] = FREE;
m_fork[n] = FREE;</action>
       <tran_glyph conn="4,74,3,-1,16">
        <action box="0,-2,6,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="4,52,34,24">
       <entry box="1,2,18,4"/>
       <exit box="1,6,18,4"/>
      </state_glyph>
     </state>
     <state_glyph node="2,6,42,72"/>
    </state>
    <state_diagram size="48,82"/>
   </statechart>
  </class>
  <!--${Cont::AO_Table}-->
  <attribute name="AO_Table" type="QP::QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;Table::inst; // opaque pointer</code>
  </attribute>
 </package>
 <!--${Comp}-->
 <package name="Comp" stereotype="0x02" namespace="DPP::">
  <!--${Comp::Philo}-->
  <class name="Philo" superclass="qpcpp::QHsm">
   <!--${Comp::Philo::m_timeEvt}-->
   <attribute name="m_timeEvt" type="CompTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${Comp::Philo::class Table}-->
   <attribute name="class Table" type="friend" visibility="0x02" properties="0x00"/>
   <!--${Comp::Philo::Philo}-->
   <operation name="Philo" type="" visibility="0x00" properties="0x00">
    <code>  : QHsm(&amp;initial),
    m_timeEvt(AO_Table, TIMEOUT_SIG, 0U)</code>
   </operation>
   <!--${Comp::Philo::getId}-->
   <operation name="getId" type="uint8_t" visibility="0x00" properties="0x00">
    <specifiers>noexcept</specifiers>
    <code>return m_timeEvt.id;</code>
   </operation>
   <!--${Comp::Philo::setId}-->
   <operation name="setId" type="void" visibility="0x00" properties="0x00">
    <specifiers>noexcept</specifiers>
    <!--${Comp::Philo::setId::id}-->
    <parameter name="id" type="uint8_t"/>
    <code>m_timeEvt.id = id;</code>
   </operation>
   <!--${Comp::Philo::SM}-->
   <statechart properties="0x00">
    <!--${Comp::Philo::SM::initial}-->
    <initial target="../1">
     <action>static bool registered = false; // starts off with 0, per C-standard
(void)e; // suppress the compiler warning about unused parameter
if (!registered) {
    registered = true;
    QS_FUN_DICTIONARY(&amp;initial);
    QS_FUN_DICTIONARY(&amp;thinking);
    QS_FUN_DICTIONARY(&amp;hungry);
    QS_FUN_DICTIONARY(&amp;eating);
}
QS_SIG_DICTIONARY(HUNGRY_SIG, this);  // signal for each Philo</action>
     <initial_glyph conn="2,3,5,1,20,5,-4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <!--${Comp::Philo::SM::thinking}-->
    <state name="thinking">
     <entry>m_timeEvt.armX(think_time(), 0U);</entry>
     <exit>(void)m_timeEvt.disarm();</exit>
     <!--${Comp::Philo::SM::thinking::TIMEOUT}-->
     <tran trig="TIMEOUT" target="../../2">
      <tran_glyph conn="2,14,3,1,20,12,-4">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${Comp::Philo::SM::thinking::TEST}-->
     <tran trig="TEST">
      <tran_glyph conn="2,18,3,-1,12">
       <action box="0,-2,11,4"/>
      </tran_glyph>
     </tran>
     <state_glyph node="2,5,16,17">
      <entry box="1,2,5,2"/>
      <exit box="1,4,5,2"/>
     </state_glyph>
    </state>
    <!--${Comp::Philo::SM::hungry}-->
    <state name="hungry">
     <entry>TableEvt *pe = Q_NEW(TableEvt, HUNGRY_SIG);
pe-&gt;philo_id = getId();
AO_Table-&gt;postLIFO(pe);</entry>
     <!--${Comp::Philo::SM::hungry::EAT}-->
     <tran trig="EAT" target="../../3">
      <tran_glyph conn="2,31,3,1,19,9,-3">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="2,24,16,12">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <!--${Comp::Philo::SM::eating}-->
    <state name="eating">
     <entry>m_timeEvt.armX(eat_time(), 0U);</entry>
     <exit>(void)m_timeEvt.disarm();

// asynchronously post event to the Container
TableEvt *pe = Q_NEW(TableEvt, DONE_SIG);
pe-&gt;philo_id = getId();
AO_Table-&gt;postLIFO(pe);</exit>
     <!--${Comp::Philo::SM::eating::TIMEOUT}-->
     <tran trig="TIMEOUT" target="../../1">
      <tran_glyph conn="2,48,3,1,22,-38,-6">
       <action box="0,-2,12,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="2,38,16,14">
      <entry box="1,2,5,2"/>
      <exit box="1,4,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="28,54"/>
   </statechart>
  </class>
 </package>
 <!--${.}-->
 <directory name=".">
  <!--${.::dpp.hpp}-->
  <file name="dpp.hpp">
   <text>#ifndef DPP_HPP
#define DPP_HPP

namespace DPP {

enum DPPSignals {
    TIMEOUT_SIG = QP::Q_USER_SIG, // time event timeout
    EAT_SIG,        // published by Table to let a philosopher eat
    DONE_SIG,       // published by Philosopher when done eating
    PAUSE_SIG,      // published by BSP to pause the application
    SERVE_SIG,      // published by BSP to serve re-start serving forks
    TEST_SIG,       // published by BSP to test the application
    MAX_PUB_SIG,    // the last published signal

    HUNGRY_SIG,     // posted direclty to Table from hungry Philo
    MAX_SIG         // the last signal
};

class Philo; // forward declaration

} // namespace DPP

enum {
    N_PHILO = 5 // number of Philos
};

$declare ${Cont::CompTimeEvt}

$declare ${Cont::AO_Table}

$declare ${Comp::Philo}

$declare ${Cont::TableEvt}

#endif // DPP_HPP</text>
  </file>
  <!--${.::table.cpp}-->
  <file name="table.cpp">
   <text>#include &quot;qpcpp.hpp&quot;
#include &quot;dpp.hpp&quot;
#include &quot;bsp.hpp&quot;

Q_DEFINE_THIS_FILE

// Active object class -------------------------------------------------------
$declare ${Cont::Table}

namespace DPP {

// helper function to provide the RIGHT neighbour of a Philo[n]
inline uint8_t RIGHT(uint8_t const n) {
    return static_cast&lt;uint8_t&gt;((n + (N_PHILO - 1U)) % N_PHILO);
}

// helper function to provide the LEFT neighbour of a Philo[n]
inline uint8_t LEFT(uint8_t const n) {
    return static_cast&lt;uint8_t&gt;((n + 1U) % N_PHILO);
}

static uint8_t const FREE = static_cast&lt;uint8_t&gt;(0);
static uint8_t const USED = static_cast&lt;uint8_t&gt;(1);

static char_t const * const THINKING = &quot;thinking&quot;;
static char_t const * const HUNGRY   = &quot;hungry  &quot;;
static char_t const * const EATING   = &quot;eating  &quot;;

// Local objects -------------------------------------------------------------
static Table l_table; // the single instance of the Table active object

// Global-scope objects ------------------------------------------------------
QP::QActive * const AO_Table = &amp;l_table; // &quot;opaque&quot; AO pointer

} // namespace DPP


//............................................................................
$define ${Cont::CompTimeEvt}

$define ${Cont::Table}</text>
  </file>
  <!--${.::philo.cpp}-->
  <file name="philo.cpp">
   <text>#include &quot;qpcpp.hpp&quot;
#include &quot;dpp.hpp&quot;
#include &quot;bsp.hpp&quot;

Q_DEFINE_THIS_FILE

namespace DPP {

// helper function to provide a randomized think time for Philos
inline QP::QTimeEvtCtr think_time() {
    return static_cast&lt;QP::QTimeEvtCtr&gt;((BSP::random() % BSP::TICKS_PER_SEC)
                                        + (BSP::TICKS_PER_SEC/2U));
}

// helper function to provide a randomized eat time for Philos
inline QP::QTimeEvtCtr eat_time() {
    return static_cast&lt;QP::QTimeEvtCtr&gt;((BSP::random() % BSP::TICKS_PER_SEC)
                                        + BSP::TICKS_PER_SEC);
}

} // namespace DPP

// Philo definition ----------------------------------------------------------
$define ${Comp::Philo}</text>
  </file>
 </directory>
</model>
